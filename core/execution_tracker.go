/*
 * Copyright 2018 Florent Biville (@fbiville)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package core

import (
	"encoding/base64"
	"fmt"
	"github.com/fbiville/headache/fs"
	"github.com/fbiville/headache/helper"
	"github.com/fbiville/headache/vcs"
	"os"
	"regexp"
	"strings"
)

type ExecutionTracker interface {
	RetrieveVersionedTemplate(configuration *Configuration) (*VersionedHeaderTemplate, error)
	TrackExecution(configurationPath *string) error
}

type HeaderTemplate struct {
	Lines []string
	Data  map[string]string
}

type ExecutionVcsTracker struct {
	Versioning   vcs.Vcs
	FileSystem   *fs.FileSystem
	Clock        helper.Clock
	ConfigLoader *ConfigurationLoader
}

// returns the header template at its current version and at the version it was last time headache ran
func (evt *ExecutionVcsTracker) RetrieveVersionedTemplate(currentConfiguration *Configuration) (*VersionedHeaderTemplate, error) {
	currentTemplate, err := evt.readCurrentTemplate(currentConfiguration)
	if err != nil {
		return nil, err
	}
	trackingPath, revision, err := evt.getPreviousExecutionRevision()
	if err != nil {
		return nil, err
	}
	if revision == "" {
		return &VersionedHeaderTemplate{
			Current:  currentTemplate,
			Previous: currentTemplate,
			Revision: "",
		}, nil
	}
	previousConfiguration, err := evt.readPreviousConfiguration(trackingPath, revision, *currentConfiguration.Path)
	if err != nil {
		return nil, err
	}
	if previousConfiguration == nil {
		return &VersionedHeaderTemplate{
			Current:  currentTemplate,
			Previous: currentTemplate,
			Revision: "",
		}, nil
	}
	previousTemplate, err := evt.readFormerTemplate(previousConfiguration, revision)
	if err != nil {
		return nil, err
	}
	return &VersionedHeaderTemplate{
		Current:  currentTemplate,
		Previous: previousTemplate,
		Revision: revision,
	}, nil
}

// tracks execution and saves the current configuration path
// returns an error if something wrong occurred
func (evt *ExecutionVcsTracker) TrackExecution(configurationPath *string) error {
	trackerPath, err := evt.getTrackerFilePath()
	if err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("cannot retrieve tracker file %v: %w", trackerPath, err)
	}
	timestamp := evt.Clock.Now().Unix()
	configurationContents, err := evt.FileSystem.FileReader.Read(*configurationPath)
	if err != nil {
		return fmt.Errorf("cannot read configuration %v: %w", *configurationPath, err)
	}
	configuration, err := evt.ConfigLoader.UnmarshalConfiguration(configurationContents)
	if err != nil {
		return fmt.Errorf("cannot unmarshal configuration %v: %w", *configurationPath, err)
	}
	header, err := evt.FileSystem.FileReader.Read(configuration.HeaderFile)
	if err != nil {
		return fmt.Errorf("cannot read header %v: %w", configuration.HeaderFile, err)
	}
	contents := fmt.Sprintf(`# Generated by headache | %d -- commit me!
encoded_configuration:%s
encoded_header:%s
`, timestamp,
		base64.StdEncoding.EncodeToString(configurationContents),
		base64.StdEncoding.EncodeToString(header),
	)
	return evt.FileSystem.FileWriter.Write(trackerPath, contents, 0640)
}

func (evt *ExecutionVcsTracker) getPreviousExecutionRevision() (string, string, error) {
	path, err := evt.getTrackerFilePath()
	if err != nil && os.IsNotExist(err) {
		return "", "", nil
	}
	if err != nil {
		return "", "", err
	}
	sha, err := evt.Versioning.LatestRevision(path)
	if err != nil {
		return "", "", err
	}
	return path, sha, nil
}

func (evt *ExecutionVcsTracker) readPreviousConfiguration(trackingPath string, revision string, currentConfigPath string) (*Configuration, error) {
	previousConfigPath, err := evt.getPreviousExecutionConfigurationPath(trackingPath)
	if err != nil {
		return nil, err
	}
	if previousConfigPath == "" {
		// assume current configuration file was present at the last run
		previousConfigPath = currentConfigPath
	}

	previousConfig, err := evt.Versioning.ShowContentAtRevision(previousConfigPath, revision)
	if err != nil {
		return nil, err
	}
	return evt.ConfigLoader.UnmarshalConfiguration([]byte(previousConfig))
}

func (evt *ExecutionVcsTracker) readCurrentTemplate(configuration *Configuration) (*HeaderTemplate, error) {
	headerBytes, err := evt.FileSystem.FileReader.Read(configuration.HeaderFile)
	if err != nil {
		return nil, err
	}
	return template(string(headerBytes), configuration.TemplateData), nil
}

func (evt *ExecutionVcsTracker) readFormerTemplate(configuration *Configuration, revision string) (*HeaderTemplate, error) {
	previousHeader, err := evt.Versioning.ShowContentAtRevision(configuration.HeaderFile, revision)
	if err != nil {
		return nil, err
	}
	return template(previousHeader, configuration.TemplateData), nil
}

func template(contents string, data map[string]string) *HeaderTemplate {
	return &HeaderTemplate{
		Lines: strings.Split(contents, "\n"),
		Data:  data,
	}
}

func (evt *ExecutionVcsTracker) getPreviousExecutionConfigurationPath(trackingPath string) (string, error) {
	bytes, err := evt.FileSystem.FileReader.Read(trackingPath)
	if err != nil {
		return "", err
	}
	regex := regexp.MustCompile("(?ms)^configuration:(.*)")
	result := regex.FindStringSubmatch(string(bytes))
	if result == nil || len(result) < 2 {
		return "", nil
	}
	return result[1], nil
}

func (evt *ExecutionVcsTracker) getTrackerFilePath() (string, error) {
	root, err := evt.Versioning.Root()
	if err != nil {
		return "", fmt.Errorf("could not proceed to repository root: %w", err)
	}
	path := fmt.Sprintf("%s/%s", root, ".headache-run")
	fileSystem := evt.FileSystem
	info, err := fileSystem.FileReader.Stat(path)
	if os.IsNotExist(err) {
		return path, err
	}
	if err != nil {
		return "", err
	}
	if info != nil && !info.Mode().IsRegular() {
		return "", fmt.Errorf("'%s' should be a regular file", path)
	}
	return path, nil
}
