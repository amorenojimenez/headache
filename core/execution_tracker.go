/*
 * Copyright 2018-2019 Florent Biville (@fbiville)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package core

import (
	"encoding/base64"
	"fmt"
	"github.com/fbiville/headache/fs"
	"github.com/fbiville/headache/helper"
	"github.com/fbiville/headache/vcs"
	"log"
	"os"
	"regexp"
	"strings"
)

// Keeps track of headache execution
type ExecutionTracker interface {

	// Retrieves the last execution's revision and two header templates,
	// based on the execution tracker file:

	// - (1) the currently configured header
	// - (2) the previous execution's header
	//
	// (1) describes the new header to be inserted in configured source files.
	// (2) describes the existing headers to be replaced by (1).
	//
	// If this is the first execution of headache, the previous execution's template
	// is set to the currently configured one and the revision is left empty.
	RetrieveVersionedTemplate(configuration *Configuration) (*VersionedHeaderTemplate, error)

	// Persists current execution's data to the execution tracker file
	TrackExecution(configurationPath *string) error
}

type HeaderTemplate struct {
	Lines []string
	Data  map[string]string
}

type ExecutionVcsTracker struct {
	Versioning   vcs.Vcs
	FileSystem   *fs.FileSystem
	Clock        helper.Clock
	ConfigLoader *ConfigurationLoader
}

func (evt *ExecutionVcsTracker) RetrieveVersionedTemplate(currentConfiguration *Configuration) (*VersionedHeaderTemplate, error) {
	currentTemplate, err := evt.readCurrentTemplate(currentConfiguration)
	if err != nil {
		return nil, err
	}
	formerTemplate, revision, err := evt.readFormerTemplate(currentConfiguration)
	if err != nil {
		return nil, err
	}
	if formerTemplate == nil {
		log.Printf("Previous execution's configuration and header not found")
		log.Printf("Assuming unchanged configuration and header")
		formerTemplate = currentTemplate
	}
	return &VersionedHeaderTemplate{
		Current:  currentTemplate,
		Previous: formerTemplate,
		Revision: revision,
	}, nil
}

func (evt *ExecutionVcsTracker) TrackExecution(configurationPath *string) error {
	trackerPath, err := evt.getTrackerFilePath()
	if err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("cannot retrieve execution tracker file %v: %w", trackerPath, err)
	}
	timestamp := evt.Clock.Now().Unix()
	configurationContents, err := evt.FileSystem.FileReader.Read(*configurationPath)
	if err != nil {
		return fmt.Errorf("cannot read configuration %v: %w", *configurationPath, err)
	}
	configuration, err := evt.ConfigLoader.UnmarshalConfiguration(configurationContents)
	if err != nil {
		return fmt.Errorf("cannot unmarshal configuration %v: %w", *configurationPath, err)
	}
	header, err := evt.FileSystem.FileReader.Read(configuration.HeaderFile)
	if err != nil {
		return fmt.Errorf("cannot read header template %v: %w", configuration.HeaderFile, err)
	}
	contents := fmt.Sprintf(`# Generated by headache | %d -- commit me!
encoded_configuration:%s
encoded_header:%s
`, timestamp,
		base64.StdEncoding.EncodeToString(configurationContents),
		base64.StdEncoding.EncodeToString(header),
	)
	return evt.FileSystem.FileWriter.Write(trackerPath, contents, 0640)
}

func (evt *ExecutionVcsTracker) readCurrentTemplate(configuration *Configuration) (*HeaderTemplate, error) {
	headerBytes, err := evt.FileSystem.FileReader.Read(configuration.HeaderFile)
	if err != nil {
		return nil, err
	}
	return template(string(headerBytes), configuration.TemplateData), nil
}

func (evt *ExecutionVcsTracker) readFormerTemplate(currentConfiguration *Configuration) (*HeaderTemplate, string, error) {
	trackerFile, err := evt.getTrackerFilePath()
	if os.IsNotExist(err) {
		return nil, "", nil
	}
	if err != nil {
		return nil, "", err
	}

	trackerContents, err := evt.FileSystem.FileReader.Read(trackerFile)
	if err != nil {
		return nil, "", err
	}

	revision, err := evt.Versioning.LatestRevision(trackerFile)
	if err != nil {
		log.Printf("Could not get previous execution revision")
		revision = ""
	}

	var previousHeaderTemplate *HeaderTemplate

	configurationMatches, err := matchValueByKeyInLine("encoded_configuration", string(trackerContents))
	if err != nil {
		return nil, "", fmt.Errorf("could not parse encoded configuration: %w", err)
	}

	if len(configurationMatches) == 2 {
		// current strategy: previous execution's configuration and header are encoded and serialized in the execution tracker file
		// in this case, they just need to read and decoded (no versioning involved)
		log.Print("Retrieving former header template by encoded configuration")
		if previousHeaderTemplate, err = evt.readFormerTemplateByConfiguration(trackerContents, configurationMatches[1]); err != nil {
			return nil, "", err
		}
	} else {
		// legacy strategy: previous execution's configuration path is (possibly) serialized in the execution tracker file
		// in that case, the revision associated with the tracker file is retrieved and the configuration path's content
		// and header content are fetched at that specific revision
		log.Print("Retrieving former header template by versioning (legacy)")
		if previousHeaderTemplate, err = evt.readFormerTemplateByVersioning(string(trackerContents), revision, currentConfiguration); err != nil {
			return nil, "", err
		}
	}
	return previousHeaderTemplate, revision, nil
}

// Decodes configuration and header content serialized in the execution tracker file
func (evt *ExecutionVcsTracker) readFormerTemplateByConfiguration(trackerContents []byte, encodedConfiguration string) (*HeaderTemplate, error) {
	configurationContents, err := base64.StdEncoding.DecodeString(encodedConfiguration)
	if err != nil {
		return nil, fmt.Errorf("could not decode encoded configuration: %w", err)
	}
	previousConfiguration, err := evt.ConfigLoader.UnmarshalConfiguration(configurationContents)
	if err != nil {
		return nil, fmt.Errorf("could not unmarshal decoded configuration: %w", err)
	}
	headerMatches, err := matchValueByKeyInLine("encoded_header", string(trackerContents))
	if err != nil {
		return nil, fmt.Errorf("could not parse encoded header template: %w", err)
	}
	if len(headerMatches) != 2 {
		return nil, fmt.Errorf("cannot retrieve encoded header template")
	}
	previousHeader, err := base64.StdEncoding.DecodeString(headerMatches[1])
	if err != nil {
		return nil, fmt.Errorf("could not decode encoded header template: %w", err)
	}
	return template(string(previousHeader), previousConfiguration.TemplateData), nil
}

// Reads the configuration and header content from the serialized configuration path at the latest revision associated
// with the execution tracker file
// If the configuration path is not serialized in the execution tracker file, the current configuration path is assumed
// (for backward compatibility's sake)
func (evt *ExecutionVcsTracker) readFormerTemplateByVersioning(trackerContents string, lastExecutionRevision string, currentConfiguration *Configuration) (*HeaderTemplate, error) {
	if lastExecutionRevision == "" {
		return nil, fmt.Errorf("could not detect previous execution's revision")
	}

	log.Printf("Last tracked execution: %s", lastExecutionRevision)
	log.Printf("Make sure the configuration and header template have not been manually committed since")

	previousConfigurationPath, err := evt.getLegacyExecutionConfigurationPath(trackerContents)
	if err != nil {
		return nil, fmt.Errorf("failed reading previous execution's configuration path: %w", err)
	}
	currentConfigurationPath := *currentConfiguration.Path
	if previousConfigurationPath == "" {
		log.Printf("Previous execution's configuration path not found, assuming current one: %s", currentConfigurationPath)
		previousConfigurationPath = currentConfigurationPath
	} else {
		log.Printf("Configuration file path at last execution was: %s", previousConfigurationPath)
	}
	previousConfigurationContents, err := evt.Versioning.ShowContentAtRevision(previousConfigurationPath, lastExecutionRevision)
	if err != nil {
		return nil, fmt.Errorf("cannot get configuration content at revision %s: %w", lastExecutionRevision, err)
	}
	previousConfiguration, err := evt.ConfigLoader.UnmarshalConfiguration([]byte(previousConfigurationContents))
	if err != nil {
		return nil, fmt.Errorf("cannot unmarshal configuration at revision %s: %w", lastExecutionRevision, err)
	}
	previousHeader, err := evt.FileSystem.FileReader.Read(previousConfiguration.HeaderFile)
	if err != nil {
		return nil, fmt.Errorf("cannot read former configuration's header at revision %s: %w", lastExecutionRevision, err)
	}
	return template(string(previousHeader), previousConfiguration.TemplateData), nil
}

func (evt *ExecutionVcsTracker) getLegacyExecutionConfigurationPath(trackingContents string) (string, error) {
	result, err := matchValueByKeyInLine("configuration", trackingContents)
	if err != nil {
		return "", err
	}
	if result == nil || len(result) < 2 {
		return "", nil
	}
	return result[1], nil
}

func (evt *ExecutionVcsTracker) getTrackerFilePath() (string, error) {
	root, err := evt.Versioning.Root()
	if err != nil {
		return "", fmt.Errorf("could not proceed to repository root: %w", err)
	}
	path := fmt.Sprintf("%s/%s", root, ".headache-run")
	info, err := evt.FileSystem.FileReader.Stat(path)
	if os.IsNotExist(err) {
		return path, err
	}
	if err != nil {
		return "", err
	}
	if info != nil && !info.Mode().IsRegular() {
		return "", fmt.Errorf("'%s' should be a regular file", path)
	}
	return path, nil
}

func matchValueByKeyInLine(key string, contents string) ([]string, error) {
	if regex, err := regexp.Compile(fmt.Sprintf("(?m)^%s:(.*)$", key)); err != nil {
		return nil, fmt.Errorf("cannot parse encoded configuration: %w", err)
	} else {
		return regex.FindStringSubmatch(contents), nil
	}
}

func template(contents string, data map[string]string) *HeaderTemplate {
	return &HeaderTemplate{
		Lines: strings.Split(contents, "\n"),
		Data:  data,
	}
}
